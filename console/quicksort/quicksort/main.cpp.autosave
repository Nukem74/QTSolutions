#include <QCoreApplication>
#include <stdlib.h>
#include <iostream>
using namespace std;

const int size = 100;


void display(int* n)
{
    for(int i = 0; i < size; i++)
    {
        cout << i << ':' << *(n++) << endl;
    }
}

void order(int a, int b)
{
    if(a < b)
    {
        int temp = b;
        b = a;
        a = temp;
    }
}

void quicksort(int* numbers, int left, int right)
{
    int pivot;                  //разрешающий элемент
    int l_hold = left;          //индекс левой границы выборки, left - левая оперируемая граница
    int r_hold = right;         //индекс правой границы выборки, right - правая оперируемая граница
    pivot = numbers[left];      //присваиваем разрешающиему элементу значение крайнего левого элемента массива
    while(left < right)         //пока левая граница не пересекла правую(индекс левой границы не превысил индекс правой границы)
    {
        while((numbers[right] >= pivot) && (left < right))
            //перебираем массив справа на лево в поисках элемента меньшего чем разрешающий, 
            //пока левая граница не пересекла правую 
            right--;
        if(left != right)//если границы не совпадают
        {   //присваиваем левому оперируемому элементу значение правого оперируемого элемента
            //и выбираем следующий элемент слева
            numbers[left] = numbers[right];
            left++;
        }
        while((numbers[left] <= pivot) && (left < right))
            //перебираем массив слева на право в поисках элемента большего чем разрешающий,
            //пока правая граница не пересекла левую
            left++;
        if(left != right)
        {
            //присваиваем правому оперируемому элементу значение левого оперируемого элемента
            //и выбираем следующий элемент справа
            numbers[right] = numbers[left];
            right--;
        }
    }
    numbers[left] = pivot;  //когда границы сойдутся на некотором индексе выборки - записываем в элемент с этим индексом
                            //значение разрешающего элемента
                            //итерация закончена именно здесь
                            //подготовка к следующей итерации
    pivot = left;           //сохраняем в переменную разрешающего элемента позицию индекса, на котором сошлись границы(наверно можно выделить для этого отдельную переменную)
    left = l_hold;          //сохраняем в переменную левой оперируемой границы индекс левой границы выборки
    right = r_hold;         //сохраняем в переменную правой оперируемой границы индекс правой границы выборки
    if(left < pivot)
    //если индекс левой оперируемой границы меньше индекса схождения границ
    //вызываем функцию сортировки выборки относительно индекса левой границы выборки и индекса схождения границ
        quicksort(numbers, left, pivot - 1);
    if(right > pivot)
    //если индекс правой оперируемой границы больше индекса схождения границ
    //вызываем функцию сортировки выборки относительно индекса схождения границ и индекса правой границы выборки
        quicksort(numbers, pivot + 1, right);
}

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);
    int exmpl1[size];
    for(int i = 0; i < size; i++)
    {
        exmpl1[i] = rand() % size;
    }
    display(exmpl1);
    //printf('\n');
    cout << endl;
    quicksort(exmpl1,0,size-1);
    display(exmpl1);
    return a.exec();
}
